/**
 * inlineTest contains the error messages and the test code.
 * When the validate function are generated by buildValidateFunction, it gives the possibility to inline the test code directly in the validate function (avoiding function calls).
 * I know that V8 can inline small functions himself but It is still a little bit faster to make inline code ourself
 */
const inlineTest = {
  alpha : {
    error   : 'must contains only letters',
    getTest : function (value) {
      return 'typeof('+value+') === "string" && /^[a-zA-Z]+$/.test('+value+')';
    }
  },

  alphanumeric : {
    error   : 'must contains only letters and numbers',
    getTest : function (value) {
      return 'typeof('+value+') === "string" && /^[0-9a-zA-Z]+$/.test('+value+')';
    }
  },

  array : {
    error   : 'must be an array',
    getTest : function (value) {
      return value+' instanceof Array';
    }
  },

  binary : {
    error   : 'must be a binary type',
    getTest : function (value) {
      return '(typeof('+value+') === "boolean" || '+value+'==="true" || '+value+'==="false" || /^[01]$/.test('+value+'))';
    }
  },

  boolean : {
    error   : 'must be a boolean',
    getTest : function (value) {
      return 'typeof('+value+') === "boolean"';
    }
  },

  decimal : {
    error   : 'must be a decimal',
    getTest : function (value) {
      return '(typeof('+value+') === "number" || /^-?[0-9]+(\\.[0-9]+)?$/.test('+value+'))';
    }
  },

  int : {
    error   : 'must be an integer',
    getTest : function (value) {
      return 'typeof('+value+') === "number" && '+value+' % 1 === 0 && !isNaN('+value+')';
    }
  },

  number : {
    error   : 'must be a number',
    getTest : function (value) {
      return 'typeof('+value+') === "number" && !isNaN('+value+')';
    },
  },

  numeric : {
    error   : 'must be a numeric value',
    getTest : function (value) {
      return '/^-?[0-9]+$/.test('+value+')';
    }
  },

  object : {
    error   : 'must be an object',
    getTest : function (value) {
      return '!('+value+' instanceof Array) && ('+value+' instanceof Object) && (typeof '+value+' !== "function")';
    }
  },

  string : {
    error   : 'must be a string',
    getTest : function (value) {
      return 'typeof('+value+') === "string"';
    }
  }

};



/**
 * Validate - "JSON validator"
 */
const validate = {
  types : Object.keys(inlineTest),

  /**
   * isType(value)
   *
   * @param {mixed} "value" : to test
   * @return {boolean} true if the test is valid, false otherwise
   */
  isArray        : new Function('value', 'return (' + inlineTest['array'       ].getTest('value') + ')'),
  isAlpha        : new Function('value', 'return (' + inlineTest['alpha'       ].getTest('value') + ')'),
  isAlphanumeric : new Function('value', 'return (' + inlineTest['alphanumeric'].getTest('value') + ')'),
  isBinary       : new Function('value', 'return (' + inlineTest['binary'      ].getTest('value') + ')'),
  isBoolean      : new Function('value', 'return (' + inlineTest['boolean'     ].getTest('value') + ')'),
  isDecimal      : new Function('value', 'return (' + inlineTest['decimal'     ].getTest('value') + ')'),
  isInt          : new Function('value', 'return (' + inlineTest['int'         ].getTest('value') + ')'),
  isNumber       : new Function('value', 'return (' + inlineTest['number'      ].getTest('value') + ')'),
  isNumeric      : new Function('value', 'return (' + inlineTest['numeric'     ].getTest('value') + ')'),
  isObject       : new Function('value', 'return (' + inlineTest['object'      ].getTest('value') + ')'),
  isString       : new Function('value', 'return (' + inlineTest['string'      ].getTest('value') + ')'),


  /**
   * Get the field name
   * TODO: this current path should be pre-computed in the main descriptor
   *
   * @param {type} path : description
   * @param {String} iterator
   * @return {type}
   */
  getFieldName : function (path, attr, iterator) {
    var _res = '';

    for (var i = 0; i < path.length; i++) {
      var _elem = path[i];
      if (_res === '') {
        if (_elem.type === 'array') {
          _res += _elem.realObjName + '[' + (iterator ? iterator : '') + ']';
        }
        else {
          _res += _elem.realObjName;
        }
      }
      else {
        if (_elem.type === 'object') {
          _res += '['+_elem.realObjName+']';
        }
        else {
          _res += '['+_elem.realObjName+'][]';
        }
      }
    }

    if (path.length) {
      _res += '['+attr+']';
    }
    else {
      _res += attr;
    }
    return _res;
  },

  /**
   * Analyze an object against a descriptor
   * TODO
   */
  buildValidateFunction : function (descriptor) {
    var _that                       = this;
    var _atLeastOneValidateFunction = false;

    var _s = 'var _errors = [];\n';
    _s += 'var _validateQueue = [];\n';

    var _path = [{ objName : '', type : 'object' }];

    // For each object in the descriptor, generate the code which will build the JSON
    for (var _objName in descriptor) {

      var _obj         = descriptor[_objName].obj; // object to build
      var _type        = descriptor[_objName].type; // object type
      var _objParent   = descriptor[_objName].objParent; // unique name of the object parent
      var _realObjName = descriptor[_objName].name; // real name of the parent object
      // var _arrChild = descriptor[_objName].arrChild; // unique name of all array children

      var _varName       = _objName+'_obj';
      var _varParentName = _objParent+'_obj';

      // detect nested array in order to close brackets
      if (_path[_path.length - 1].objName===_objParent) {
        _path.push({ objName : _objName, type : _type, realObjName : _realObjName });
      }
      else {
        while (_path.length > 1 && _path[_path.length-1].objName!==_objParent) {
          var _pathObject = _path.pop();
          if (_pathObject.type==='array') {
            _s += '}\n';
          }
        }
        _path.push({ objName : _objName, type : _type, realObjName : _realObjName });
      }


      // if this is an object
      if (_type === 'object') {
        if (_objName === 'main0') {
          _s += 'var '+_varName+' = data;\n';
        }
        else {
          _s += 'var '+_varName+' = '+ _varParentName+'["'+_realObjName+'"];\n';
        }
      }
      else if (_type === 'array') {
        if (_objName === 'main0') {
          var _varNameArray = _objName+'_arr';
          _s += 'var '+_varNameArray+' = data;\n';
          var _varNameIterator = _objName+'_i';
          _s += 'for(var '+_varNameIterator+'=0;'+ _varNameIterator+'<'+_varNameArray+'.length; '+_varNameIterator+'++){\n';
          _s += 'var '+_varName+' = '+ _varNameArray+'['+_varNameIterator+'];\n';
        }
        else {
          _varNameIterator = _objName+'_i';
          _s += 'for(var '+_varNameIterator+'=0;'+ _varNameIterator+'<'+_varParentName+'["'+_realObjName+'"].length; '+_varNameIterator+'++){\n';
          _s += 'var '+_varName+' = '+ _varParentName+'["'+_realObjName+'"]['+_varNameIterator+'];\n';
        }
      }

      // Test every attribute of the object
      for (var _attr in _obj) {
        var _testedVariable = _varName+'["'+_attr+'"]';
        var _test = _obj[_attr];
        var _code = this.getConditionCode(_testedVariable, _test);
        // Add a condition only if the developer has specified a validator array
        if (_code.testStr) {
          _s += 'if(!('+_code.testStr+')){\n';
          var _field = _that.getFieldName(_path.slice(2),_attr, _varNameIterator);
          _field     = _field.replace(_varNameIterator, '" + ' + _varNameIterator + ' + "');
          _s += '  _errors.push({"value":'+_testedVariable+', "field":"'+ _field +'", "error": "'+_code.errorMessage+'"});\n';
          _s += 'if(callback){callback(_errors);};\n';
          _s += '  return _errors;\n'; // wrong, i should only return for object or array
          _s += '}\n';
        }
        if (_code.nbFunctions || _code.formatStr) {
          _s += 'else{\n';
        }
        if (_code.formatStr) {
          _s += _code.formatStr;
        }
        if (_code.nbFunctions) { // TODO improve
          _atLeastOneValidateFunction = true;
          _field = _that.getFieldName(_path.slice(2),_attr, _varNameIterator);
          _field = _field.replace(_varNameIterator, '" + ' + _varNameIterator + ' + "');
          _s += '_validateQueue.push({"value": '+_testedVariable+', "fnName":"'+_objName+'_'+_attr+'", "field":"'+ _field +'"});\n';
        }
        if (_code.nbFunctions || _code.formatStr) {
          _s += '}\n';
        }
      }
    }

    // If the are loop which are not closed by a bracket, close them
    while (_path.length > 1) {
      _pathObject = _path.pop();
      if (_pathObject.type==='array') {
        _s += '}\n';
      }
    }

    if (_atLeastOneValidateFunction) {
      _s += 'var _incomplete = _validateQueue.length;\n';
      _s += 'for (var i = 0; i < _validateQueue.length; i++) {\n';
      _s += '  var _testedValue = _validateQueue[i];\n';
      _s += '  (function(testedValue){\n';
      _s += '    var _fn = validateFn[testedValue.fnName];\n';
      _s += '    _fn.call({"value":testedValue.value}, function(message){\n';
      _s += '      if(message){\n';
      _s += '        _errors.push({"value":testedValue.value, "field":testedValue.field, "error":message });\n';
      _s += '      }\n';
      _s += '      _incomplete--;\n';
      _s += '      if(_incomplete===0){\n';
      _s += '        callback(_errors);\n';
      _s += '      }\n';
      _s += '    });\n';
      _s += '  })(_testedValue);\n';
      _s += '};\n';
    }
    else {
      _s += 'if(callback){callback(_errors);};\n';
    }
    _s += ' return _errors;\n';

    // console.log('\n\n'+_s+'\n\n');

    // The function is built, we compile it and check errors in the same time
    var _fn;
    try {
      _fn = new Function('data', 'validateFn', 'callback', _s);
    }
    catch (err) {
      throw new Error('Lunaris.validate: Impossible to compile the JSON validator.\n'+err+'\n--------------------------------\n'+_s+'\n--------------------------------\n');
    }
    return _fn;
  },

  /*
   *
   */
  getConditionCode : function (varName, params) {
    var _test         = '';
    var _type         = '';
    var _errorMessage = '';
    var _formatStr    = '';
    var _fnList       = [];

    // Check that we receive an array
    if (!(params instanceof Array)) {
      throw new Error('Lunaris.validate: the descriptor is invalid for the variable '+varName+'. You must use an array [] instead of '+JSON.stringify(params));
    }
    // store the first argument which is the type
    if (params.length!==0) {
      _type = params[0];
      if (inlineTest[_type]) {
        _test         = inlineTest[_type].getTest(varName);
        _errorMessage = inlineTest[_type]['error'];
      }
      else {
        throw new Error('Lunaris.validate: Unknown descriptor type "'+_type+'" in '+varName+':'+JSON.stringify(params));
      }
    }
    else {
      return {};
    }

    // anaylze other descriptor params
    var i = 1;
    while (i < params.length) {
      var _argument = params[i++];
      switch (_argument) {
        case 'min':
          var _value = params[i++];
          if (_type === 'int' || _type === 'number') {
            _test += ' && '+varName+'>='+_value;
          }
          else if (_type === 'numeric') {
            _test += ' && parseInt('+varName+')>='+_value;
          }
          else if (_type === 'decimal') {
            _test += ' && parseFloat('+varName+')>='+_value;
          }
          else if (_type === 'string' || _type === 'alpha' || _type === 'alphanumeric' || _type === 'array') {
            _test += ' && '+varName+'.length>='+_value;
          }
          break;
        case 'max':
          _value = params[i++];
          if (_type === 'int' || _type === 'number') {
            _test += ' && '+varName+'<='+_value;
          }
          else if (_type === 'numeric') {
            _test += ' && parseInt('+varName+')<='+_value;
          }
          else if (_type === 'decimal') {
            _test += ' && parseFloat('+varName+')<='+_value;
          }
          else if (_type === 'string' || _type === 'alpha' || _type === 'alphanumeric' || _type === 'array') {
            _test += ' && '+varName+'.length<='+_value;
          }
          break;
        case 'toBoolean':
          if (_type === 'binary') {
            _formatStr += varName+'= ('+varName+' === true || '+varName+' === "true" || '+varName+' === "1" || '+varName+' === 1) ? true:false; ';
          }
          break;
        case 'toInt':
          if (_type === 'numeric') {
            _formatStr += varName+'= parseInt('+varName+');';
          }
          break;
        case 'toNumber':
          if (_type === 'decimal') {
            _formatStr += varName+'= parseFloat('+varName+');';
          }
          break;
        default:
          if (typeof _argument === 'function') {
            _fnList.push(_argument);
          }
          // throw new Error('Lunaris.validate: Unknown descriptor parameter "'+_argument+'" in '+varName+':'+JSON.stringify(params));
          break;
      }
    }

    var _res = {
      testStr      : _test,
      errorMessage : _errorMessage
    };

    // TODO refactor
    if (_formatStr) {
      _res.formatStr = _formatStr;
    }

    if (_fnList.length > 0) {
      _res.nbFunctions = _fnList.length;
    }

    return _res;
  }

};

module.exports = validate;
